/*
 * Copyright (C) 2016 Sergej Shafarenka, www.halfbit.de
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package de.halfbit.featured;

import org.jetbrains.annotations.NotNull;

/**
 * Feature defines a self-contained piece of application logic decoupled from the rest of
 * the application through asynchronous callbacks. Feature callbacks are events a feature
 * can receive from or send to other features. Features do only communicate to each other
 * through these asynchronous callbacks and never directly.
 * <p/>
 * Typically you will write multiple features implementing different aspects of your app.
 * There is no restriction on what feature implementation can do. There can be loading data
 * features, showing data features, logging features, UI features or even features adding
 * new UI elements and handling their behavior.
 * <p/>
 * First thing to do before implementing features, is to define events the features will
 * receive. For that you create a new class by extending this abstract {@code Feature} class
 * and defining feature callbacks.
 * <p/>
 * <pre>
 * public class LifecycleFeature extends Feature<LifecycleFeatureHost> {
 *     &#64;FeatureEvent protected void onCreate(Bundle savedInstanceState) { }
 *     &#64;FeatureEvent protected void onStart() { }
 *     &#64;FeatureEvent protected void onStop() { }
 *     &#64;FeatureEvent protected void onDestroy() { }
 * }
 * </pre>
 * As you can see we created a feature type capable to handle standard Activity's or
 * Fragment's lifecycle events. Now we are ready to implement features by extending this
 * base class. Every feature can now override one or many of these callbacks to implement
 * its logic. A simple logger feature could look like this:
 * <pre>
 * public class LoggerFeature extends LifecycleFeature {
 *     &#64;Override protected void onCreate(Bundle savedInstanceState) { Log.d(TAG, "onCreate"); }
 *     &#64;Override protected void onStart() { Log.d(TAG, "onStart"); }
 *     &#64;Override protected void onStop() { Log.d(TAG, "onStop"); }
 *     &#64;Override protected void onDestroy() { Log.d(TAG, "onDestroy"); }
 * }
 * </pre>
 * Features live inside a shared container which is called {@link FeatureHost}. It is
 * responsible for hosting features and dispatching events between them. Once we have
 * feature implementations we can now register them in a feature host.
 * <pre>
 * LifecycleFeatureHost host = new LifecycleFeatureHost(this)
 *     .with(new LoggerFeature())
 *     .with(new ToolbarFeature())
 *     .with(new LoadItemFeature())
 *     .with(...);
 * </pre>
 * You might notice, there is no such class as {@code LifecycleFeatureHost} in the library,
 * but we reference it already twice. You are absolutely right. This is where the magic
 * begins. After we annotated callbacks methods of {@code LifecycleFeature} with
 * {@link FeatureEvent}, the library has created a feature host implementation for us,
 * which capable to dispatch those events between our features.
 * <p/>
 * Now we come to the last step. We need to dispatch activity events to the features. That
 * is really easy. We override activity's lifecycle callbacks as following:
 * <pre>
 * &#64;Override public void onCreate(Bundle savedInstanceState) {
 *     mFeatureHost = new LifecycleFeatureHost(this).with(new LoggerFeature());
 *     mFeatureHost.dispatchOnCreate(savedInstanceState);
 * }
 *
 * &#64;Override public void onStart() { mFeatureHost.dispatchOnStart(); }
 *
 * &#64;Override public void onStop() { mFeatureHost.dispatchOnStop(); }
 *
 * &#64;Override public void onDestroy() { mFeatureHost.dispatchOnDestroy(); }
 * </pre>
 * Dispatch methods are also generated by the library and they reflect same events you
 * defined when you created you base feature. Features can use {@link #getFeatureHost()}
 * method to access the feature host and call dispatch methods by themselves in order
 * to dispatch their events further.
 *
 * @param <FH> the feature host class the library generates for your feature class
 * @author sergej shafarenka
 * @see FeatureHost
 */
public abstract class Feature<FH extends FeatureHost, C> {

    private FH mFeatureHost;

    @NotNull protected C getContext() {
        assertFeatureHostAttached();
        //noinspection unchecked
        return (C) mFeatureHost.getContext();
    }

    void attachFeatureHost(FH featureHost) {
        mFeatureHost = featureHost;
    }

    @NotNull protected FH getFeatureHost() {
        assertFeatureHostAttached();
        return mFeatureHost;
    }

    private void assertFeatureHostAttached() {
        if (mFeatureHost == null) {
            throw new IllegalStateException("FeatureHost is not attached");
        }
    }

}
